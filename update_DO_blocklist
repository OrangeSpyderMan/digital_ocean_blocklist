#!/bin/bash

# Fail fast and treat unset vars as errors
set -euo pipefail

# ==========================================
# DEFAULT CONFIGURATION
# ==========================================
URL="https://digitalocean.com/geo/google.csv"
FILE="crowdsec_blocklist.csv"
DURATION="876000h"  # Default: 100 years in hours
REASON="DigitalOcean"

# ==========================================
# SUDO DETECTION
# ==========================================
# If user ID is 0 (root), sudo is empty. Otherwise, sudo is "sudo".
if [ "$(id -u)" -eq 0 ]; then
    SUDO_CMD=""
else
    SUDO_CMD="sudo"
fi

# Dry-run mode (0/1). When enabled, cscli commands are printed, not executed.
DRY_RUN=0
# Keep generated file after import (0/1)
KEEP_FILE=0
# Verbose mode (0/1) - print extra details
VERBOSE=0


# ==========================================
# FUNCTIONS
# ==========================================

# Print usage information
usage() {
    exit_code=${1:-1}
    echo "Usage: $0 [OPTIONS] {download|append|sync|refresh}"
    echo ""
    echo "Actions:"
    echo "  download : Download and format the CSV only (no import)"
    echo "  append   : Download and import (adds to existing bans)"
    echo "  sync     : Download, DELETE old bans matching the reason, then import"
    echo "  refresh  : Alias for 'sync' (download, delete old, import)"
    echo ""
    echo "Options:"
    echo "  -u URL      Override blocklist URL (default: $URL)"
    echo "  -d DURATION Override duration (default: $DURATION). Use 'h' for hours."
    echo "  -r REASON   Override reason/scenario name (default: '$REASON')"
    echo "  -n, --dry-run  Do not execute cscli; show actions only"
    echo "  -k, --keep-file  Keep the generated CSV file after import"
    echo "  -f, --filename  Set output filename (default: $FILE). Temporary file will be named \"_<basename>.tmp.XXXXXX\" in same directory."
    echo "  --no-sudo    Do not use 'sudo', even if not running as root"
    echo "  --sudo-command CMD  Specify a command to use instead of 'sudo' (e.g. 'doas')"
    echo "  -v, --verbose  Print additional debug/verbose information"
    echo "  -h, --help   Show this help message"
    exit "$exit_code"
}

# Function to download and format the list
prepare_list() {
    echo "Downloading and processing list..."

    # Create temp file in same directory as $FILE, named _<basename>.tmp
    dir=$(dirname -- "$FILE")
    base=$(basename -- "$FILE")

    # Use mktemp in the same directory to avoid races: pattern _<basename>.tmp.XXXXXX
    # Ensure dir exists and writable (dirname always returns '.' at minimum)
    if [ ! -d "$dir" ]; then
        echo "Error: Directory '$dir' does not exist for output file '$FILE'" >&2
        exit 3
    fi
    if [ ! -w "$dir" ]; then
        echo "Error: No write permission in directory '$dir' for output file '$FILE'" >&2
        exit 4
    fi

    tmpfile=$(mktemp "$dir/_${base}.tmp.XXXXXX")
    # Use -fsSL to fail on HTTP errors and be silent; -L to follow redirects
    if ! curl -fsSL "$URL" -o "$tmpfile"; then
        echo "Error: Failed to download $URL" >&2
        rm -f "$tmpfile"
        exit 2
    fi

    # Verbose: show download file and line counts
    vprint "Downloaded to: $tmpfile"
    if [ "${VERBOSE:-0}" -eq 1 ]; then
        lines=$(wc -l < "$tmpfile" || true)
        vprint "Downloaded lines: $lines"
    fi

    # Enrichment: add header and convert each CIDR into a CrowdSec decision CSV line
    vprint "Enrichment: adding header 'duration,scope,value,reason' and mapping each CIDR -> 'duration,range,<cidr>,<reason>'"
    echo "duration,scope,value,reason" > "$FILE"
    awk -F, -v dur="$DURATION" -v reas="$REASON" 'NF > 0 {print dur ",range," $1 "," reas}' "$tmpfile" >> "$FILE"

    # Count resulting decisions (subtract header)
    if [ -f "$FILE" ]; then
        total_lines=$(wc -l < "$FILE" 2>/dev/null || true)
        if [ -n "$total_lines" ] && [ "$total_lines" -gt 0 ]; then
            decisions=$((total_lines - 1))
        else
            decisions=0
        fi
        vprint "Wrote CSV to: $FILE (decisions: $decisions)"
        if [ "${VERBOSE:-0}" -eq 1 ]; then
            vprint "Sample lines from CSV:"
            head -n 5 "$FILE" | sed -n '1,5p' | sed 's/^/[VERBOSE]  /'
        fi
    fi

    rm -f "$tmpfile"
    echo "File saved to $FILE"
}

# Function to delete existing decisions for this reason
flush_old() {
    echo "Flushing old '$REASON' decisions..."
    vprint "Preparing to delete decisions for scenario: $REASON"
    run_cmd cscli decisions delete --scenario "$REASON"
}

# Function to import the new list
import_list() {
    echo "Importing new list to CrowdSec..."
    vprint "Preparing to import decisions from: $FILE"
    run_cmd cscli decisions import -i "$FILE"
}

# Helper to run a command or echo it in dry-run mode
run_cmd() {
    # Build command array, prepend sudo if needed
    local cmd=("$@")
    if [ -n "${SUDO_CMD:-}" ]; then
        cmd=("$SUDO_CMD" "${cmd[@]}")
    fi

    if [ "${DRY_RUN:-0}" -eq 1 ]; then
        echo "[DRY-RUN] Would run: ${cmd[*]}"
    else
        if [ "${VERBOSE:-0}" -eq 1 ]; then
            echo "[VERBOSE] Running: ${cmd[*]}"
            if [ -n "${SUDO_CMD:-}" ]; then
                echo "[VERBOSE] Note: $SUDO_CMD will be used"
            fi
        fi
        "${cmd[@]}"
    fi
}

# Print when verbose enabled
vprint() {
    if [ "${VERBOSE:-0}" -eq 1 ]; then
        echo "[VERBOSE] $*"
    fi
}



# ==========================================
# ARGUMENT PARSING
# ==========================================
# Parse options (short and long) in a single loop
while [ "$#" -gt 0 ]; do
    case "$1" in
        -n|--dry-run)
            DRY_RUN=1
            shift
            ;;
        -k|--keep-file)
            KEEP_FILE=1
            shift
            ;;
        -f|--filename)
            if [[ "$1" = "-f" ]]; then
                shift
                if [ "$#" -eq 0 ]; then
                    echo "Error: -f requires an argument" >&2
                    usage 1
                fi
                FILE="$1"
                shift
            else
                # --filename or --filename=...
                if [[ "$1" == *=* ]]; then
                    FILE="${1#--filename=}"
                    shift
                else
                    shift
                    if [ "$#" -eq 0 ]; then
                        echo "Error: --filename requires an argument" >&2
                        usage 1
                    fi
                    FILE="$1"
                    shift
                fi
            fi
            ;;
        --no-sudo)
            SUDO_CMD=""
            shift
            ;;
        --sudo-command*)
            if [[ "$1" == *=* ]]; then
                SUDO_CMD="${1#--sudo-command=}"
                shift
            else
                shift
                if [ "$#" -eq 0 ]; then
                    echo "Error: --sudo-command requires an argument" >&2
                    usage 1
                fi
                SUDO_CMD="$1"
                shift
            fi
            ;;
        -v|--verbose)
            VERBOSE=1
            shift
            ;;
        -u)
            shift
            URL="$1"
            shift
            ;;
        -d)
            shift
            DURATION="$1"
            shift
            ;;
        -r)
            shift
            REASON="$1"
            shift
            ;;
        -h|--help)
            usage 0
            ;;
        download|append|sync|refresh)
            ACTION="$1"
            shift
            break
            ;;
        *)
            echo "Error: Unknown option or action: $1" >&2
            usage 1
            ;;
    esac
done

# If ACTION wasn't set by the parser, require an action; otherwise show help
if [ -z "${ACTION:-}" ]; then
    echo "Error: Missing action." >&2
    usage 1
fi


# Main Logic based on the parsed action
case "$ACTION" in
    download)
        # Just download and format, don't touch CrowdSec
        prepare_list
        ;;
        
    append)
        # Download and add new decisions (keep existing ones)
        prepare_list
        import_list
        if [ "${DRY_RUN:-0}" -eq 1 ]; then
            echo "[DRY-RUN] No changes made"
        else
            if [ "${KEEP_FILE:-0}" -ne 1 ]; then
                rm -f "$FILE"
            else
                echo "Keeping file: $FILE"
            fi
        fi
        ;;
        
    refresh|sync)
        # Download, delete old ones, and add new ones (The "Overwrite" method)
        prepare_list
        flush_old
        import_list
        if [ "${DRY_RUN:-0}" -eq 1 ]; then
            echo "[DRY-RUN] No changes made"
        else
            if [ "${KEEP_FILE:-0}" -ne 1 ]; then
                rm -f "$FILE"
            else
                echo "Keeping file: $FILE"
            fi
        fi
        ;;
        
    *)
        echo "Error: Invalid action '$ACTION'"
        usage 1
        ;;
esac